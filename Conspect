# Series 

*Структура/объект Series представляет из себя объект, похожий на одномерный массив, но отличительной его чертой является наличие индексов, вдоль каждого элемента из списка. Такая особенность превращает его в ассоциативный массив или словарь в Python.*
 >>> import pandas as pd
>>> my_series = pd.Series([5, 6, 7, 8, 9, 10])
>>> my_series
0     5
1     6
2     7
3     8
4     9
5    10
dtype: int64
>>> 
*В строковом представлении объекта Series, индекс находится слева, а сам элемент справа. Если индекс явно не задан, то pandas автоматически создаёт RangeIndex от 0 до N-1, где N общее количество элементов. Также стоит обратить, что у Series есть тип хранимых элементов, в нашем случае это int64, т.к. мы передали целочисленные значения.
У объекта Series есть атрибуты через которые можно получить список элементов и индексы, это values и index соответственно*
>>> my_series.index
RangeIndex(start=0, stop=6, step=1)
>>> my_series.values
array([ 5,  6,  7,  8,  9, 10], dtype=int64) 

*Доступ к элементам объекта Series возможны по их индексу (вспоминается аналогия со словарем и доступом по ключу).*

>>> my_series[4]
9

*Индексы можно задавать явно:*

>>> my_series2 = pd.Series([5, 6, 7, 8, 9, 10], index=['a', 'b', 'c', 'd', 'e', 'f'])
>>> my_series2['f']
10

*Делать выборку по нескольким индексам и осуществлять групповое присваивание:*

>>> my_series2[['a', 'b', 'f']]
a     5
b     6
f    10
dtype: int64
>>> my_series2[['a', 'b', 'f']] = 0
>>> my_series2
a    0
b    0
c    7
d    8
e    9
f    0
dtype: int64

*Фильтровать Series как душе заблагорассудится, а также применять математические операции и многое другое:*

>>> my_series2[my_series2 > 0]
c    7
d    8
e    9
dtype: int64

>>> my_series2[my_series2 > 0] * 2
c    14
d    16
e    18
dtype: int64

*Если Series напоминает нам словарь, где ключом является индекс, а значением сам элемент, то можно сделать так:*

>>> my_series3 = pd.Series({'a': 5, 'b': 6, 'c': 7, 'd': 8})
>>> my_series3
a    5
b    6
c    7
d    8
dtype: int64
>>> 'd' in my_series3
True

*У объекта Series и его индекса есть атрибут name, задающий имя объекту и индексу соответственно.*

>>> my_series3.name = 'numbers'
>>> my_series3.index.name = 'letters'
>>> my_series3
letters
a    5
b    6
c    7
d    8
Name: numbers, dtype: int64

*Индекс можно поменять "на лету", присвоив список атрибуту index объекта Series*

>>> my_series3.index = ['A', 'B', 'C', 'D']
>>> my_series3
A    5
B    6
C    7
D    8
Name: numbers, dtype: int64

*Имейте в виду, что список с индексами по длине должен совпадать с количеством элементов в Series.*

# DataFrame

*Объект DataFrame лучше всего представлять себе в виде **обычной таблицы**, ведь DataFrame является табличной структурой данных. Столбцами в объекте DataFrame выступают объекты Series, строки которых являются их непосредственными элементами.
Объект DataFrame имеет 2 индекса: по строкам и по столбцам. Если индекс по строкам явно не задан, то pandas задаёт целочисленный индекс RangeIndex от 0 до N-1, где N это количество строк в таблице.*

# Доступ по индексу в DataFrame

*Индекс по строкам можно задать разными способами, например, при формировании самого объекта DataFrame или "на лету". 
Объекты Series из DataFrame будут иметь **те же индексы**, что и объект DataFrame
Доступ к строкам по индексу возможен несколькими способами:*

- .loc - используется для доступа по строковой метке
- .iloc - используется для доступа по числовому значению (начиная от 0)

*К столбцам можно обращаться, используя атрибут или нотацию словарей Python, т.е. **df.population и df['population']** это одно и то же.*

## Сбросить индексы можно вот так:

>>> df.reset_index()
  Country Code     country  population    square
0           KZ  Kazakhstan       17.04   2724902
1           RU      Russia      143.50  17125191
2           BY     Belarus        9.50    207600
3           UA     Ukraine       45.50    603628

*Особо ленивые могут просто написать **del df['density']**.
Переименовывать столбцы нужно через метод rename*

# Чтение и запись данных

*Pandas поддерживает все самые популярные форматы хранения данных: **csv, excel, sql, буфер обмена, html** и многое другое
Аргумент sep указывает разделитесь столбцов. Существует ещё масса способов сформировать DataFrame из различных источников, но наиболее часто используют **CSV**, **Excel** и **SQL**. Например, с помощью функции **read_sql**, pandas может выполнить SQL запрос и на основе ответа от базы данных сформировать необходимый DataFrame. За более подробной информацией стоит обратиться к официальной документации.*

# Анализ временных рядов
*В pandas очень удобно анализировать временные ряды. В качестве показательного примера я буду использовать цену на акции корпорации Apple за 5 лет по дням.* 

*Здесь мы формируем DataFrame с DatetimeIndex по колонке Date и сортируем новый индекс в правильном порядке для работы с выборками. Если колонка имеет формат даты и времени отличный от ISO8601, то для правильного перевода строки в нужный тип, можно использовать метод pandas.to_datetime.*

***Resampling** мощный инструмент при работе с временными рядами (time series), помогающий переформировать выборку так, как удобно вам. Метод resample первым аргументом принимает строку rule.*

# Визуализация данных в pandas
Для визуального анализа данных, pandas использует библиотеку **matplotlib**.
